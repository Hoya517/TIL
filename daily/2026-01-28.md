# TIL – 상품 CRUD & Soft Delete 설계 정리

## 1. 상품 CRUD 구현
- 상품 등록 / 단건 조회 / 목록 조회 / 수정 / 삭제 구현 완료
- 수정은 **PUT(전체 갱신)** 사용  
  → 요청 바디 값을 그대로 반영하는 현재 스펙에 가장 적합
- Validation 적용 및 예외 처리(`@ControllerAdvice`)로 응답 포맷 통일
- 조회/변경 트랜잭션 분리 (`readOnly = true`)

---

## 2. Editor / Command 도입 판단
- 현재는 **PUT-only + 단순 변경 규칙**
- ProductEditor, Command 도입은 오버엔지니어링이라 판단
- `product.update(name, price)` 형태로 단순 유지  
→ **필요해질 때 확장**하는 방향 선택

---

## 3. DTO & 패키지 구조
- `model` → `dto`로 네이밍 변경
- Request/Response는 외부 입출력 전용 DTO로 명확히 분리

---

## 4. Soft Delete 설계
- `delete_yn` 대신 `deleted_at(LocalDateTime)` 사용
- 삭제 시점 기록 가능, 실무적으로 활용도 높음

### Hibernate 6 주의사항
- `@Where` ❌ (Hibernate 6에서 제거)
- 대안: **`@SQLRestriction`**

```java
@SQLDelete(sql = "UPDATE product SET deleted_at = now() WHERE id = ?")
@SQLRestriction("deleted_at IS NULL")
```

---

## 5. BaseEntity 분리 전략

- **BaseEntity**
  - 생성/수정 시간 등 모든 엔티티에 공통으로 필요한 요소만 포함
- **SoftDeletableEntity**
  - 소프트 삭제가 필요한 도메인만 선택적으로 상속
  - `deletedAt`, `softDelete()` 책임 분리

→ 삭제 정책을 BaseEntity에 강제하지 않고 **도메인 단위로 분리**

---

## 6. 연관관계 주의점

- Soft delete된 `Product`는 `Order` 조회 시 연관관계에서 `null`이 될 수 있음
- 이는 `@SQLRestriction`이 연관 조회에도 적용되기 때문

### 해결 전략
- 엔티티 연관관계에 의존하지 않음
- 조회 시 **JOIN + DTO** 방식으로 필요한 필드만 직접 조회
