
# 🚀 TIL - Circuit Breaker (Resilience4j)

## 📅 Today’s Learning
- Circuit Breaker 패턴 이해
- Resilience4j 설정 및 적용
- Fallback 메커니즘 동작 확인
- Event Listener를 통한 상태 변화 추적
- Prometheus 연동을 통한 모니터링 확인

---

# 1️⃣ Circuit Breaker란?

마이크로서비스 환경에서는 서비스 간 호출이 네트워크 기반으로 이루어진다.

이때 다음과 같은 문제가 발생할 수 있다:

- 외부 서비스 장애
- 응답 지연 증가
- 타임아웃 누적
- 스레드 풀 고갈
- 장애의 연쇄 전파

Circuit Breaker는 이러한 장애 확산을 방지하기 위한 장애 격리 패턴이다.

---

## 🎯 목적

- 실패를 빠르게 감지
- 장애 전파 차단
- 시스템 전체 안정성 확보
- Fail Fast 전략 적용

---

# 2️⃣ Circuit Breaker 상태 변화

## 1. Closed (기본 상태)

- 모든 요청을 정상 통과
- 실패율을 계산
- 설정된 임계값 초과 시 Open 상태로 전환

예시:
- 최근 5번 호출 중 3번 실패 → 실패율 60%
- 임계값 50% 초과 → Open 전환

---

## 2. Open

- 모든 요청을 즉시 차단
- 비즈니스 로직 실행하지 않음
- 바로 Fallback 호출

설정된 시간(waitDurationInOpenState) 경과 후 Half-Open 상태로 전환

---

## 3. Half-Open

- 일부 요청만 허용
- 성공 시 Closed로 복귀
- 실패 시 다시 Open

---

# 3️⃣ Resilience4j란?

Spring Boot에서 사용하는 경량 Circuit Breaker 라이브러리.

### 특징

- Annotation 기반 적용
- 다양한 설정 옵션 제공
- Event Listener 지원
- Micrometer 연동 가능

---

# 4️⃣ 의존성 설정

```groovy
implementation 'io.github.resilience4j:resilience4j-spring-boot3:2.2.0'
implementation 'org.springframework.boot:spring-boot-starter-aop'
implementation 'org.springframework.boot:spring-boot-starter-actuator'
implementation 'io.micrometer:micrometer-registry-prometheus'
```

주의:
Spring Cloud starter가 아닌 직접 resilience4j 라이브러리를 사용

---

# 5️⃣ CircuitBreaker 적용 코드

```java
@CircuitBreaker(name = "productService", fallbackMethod = "fallbackGetProductDetails")
public Product getProductDetails(String productId) {
    if ("111".equals(productId)) {
        throw new RuntimeException("Empty response body");
    }
    return new Product(productId, "Sample Product");
}
```

---

## Fallback 메서드

```java
public Product fallbackGetProductDetails(String productId, Throwable t) {
    return new Product(productId, "Fallback Product");
}
```

### 특징

- 동일한 파라미터 유지
- 마지막 인자로 Throwable 추가
- 예외 발생 시 대체 응답 제공

---

# 6️⃣ 주요 설정 값

```yaml
resilience4j:
  circuitbreaker:
    configs:
      default:
        slidingWindowType: COUNT_BASED
        slidingWindowSize: 5
        minimumNumberOfCalls: 5
        failureRateThreshold: 50
        permittedNumberOfCallsInHalfOpenState: 3
        waitDurationInOpenState: 20s
```

### 설정 의미

- slidingWindowSize: 최근 5번 호출 기준
- minimumNumberOfCalls: 최소 5번 호출 후 계산
- failureRateThreshold: 실패율 50% 초과 시 Open
- waitDurationInOpenState: 20초 후 Half-Open

---

# 7️⃣ 실습 시나리오

정상 호출:
/product/11
→ Closed 유지

실패 유도:
/product/111
→ 예외 발생
→ 실패율 증가
→ Open 전환
→ Fallback 실행

---

# 8️⃣ Event Listener

```java
circuitBreakerRegistry.circuitBreaker("productService")
    .getEventPublisher()
    .onStateTransition(...)
    .onFailureRateExceeded(...)
    .onCallNotPermitted(...)
    .onError(...);
```

확인 가능한 이벤트:

- 상태 전환
- 실패율 초과
- 호출 차단
- 오류 발생

---

# 9️⃣ Prometheus 연동

접속 경로:
/actuator/prometheus

확인 가능한 항목:

- circuitbreaker_calls
- circuitbreaker_state
- circuitbreaker_failure_rate

향후 Grafana를 통해 시각화 가능

---

# 🔟 오늘의 핵심 인사이트

1. MSA는 네트워크 장애를 전제로 설계해야 한다.
2. Circuit Breaker는 성능 향상이 아니라 장애 확산 방지 도구이다.
3. Open 상태에서는 비즈니스 로직이 실행되지 않는다.
4. Fallback은 사용자 경험을 보호하기 위한 안전장치다.

---

# 🎯 최종 정리

Circuit Breaker는

> 장애를 숨기는 기술이 아니라  
> 장애를 통제하는 기술이다.

MSA 환경에서 안정성을 확보하기 위한 핵심 패턴임을 이해했다.
